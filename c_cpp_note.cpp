/********************************************************************************************
	C/C++ Learning note
	
	@date: 2018.01.22
	@author: stdEnable
	

	
  data:
	1.《中文版：Linux C/C++编程一站式学习》http://songjinshan.com/akabook/zh/index.html
	2.《MOOC PKU C++》

  code:  (note; question; think)     @The end

  plan:
	1. 完成《中文版：Linux C/C++编程一站式学习》的学习，记录。  
	2. 完成 MOOC
	
  log:
	1. review & rebuild 					@2018.02.25
 
			
********************************************************************************************/


/********************************************************************************************
  1.《中文版：Linux C/C++编程一站式学习》http://songjinshan.com/akabook/zh/index.html			
********************************************************************************************/

// ======================================================================
// 2. 变量、常量和表达式
// ======================================================================

// 双引号是字符串字面值的界定符，夹在双引号中间的一串字符才是它的内容。

// 至可以把整个程序写成一行（但 include 必须单独占一行）：

// 常量（Constant）是程序中最基本的元素，有字符常量（Character Constant）、整数（Integer）常量、浮点数（Floating Point）常量和枚举常量。

// 在格式化字符串中%号（Percent Sign）后面加上字母c、d、f分别表示字符型、整型和浮点型的转换说明（Conversion Specification），
// 转换说明只在格式化字符串中占个位置，并不出现在最终的打印结果中，这种用法通常叫做占位符（Placeholder）。
// 这也是一种字面意思与真实意思不同的情况，但是转换说明和转义序列又有区别， 转义序列是编译时处理的，而转换说明是在运行时由printf函数处理的 ：

//  printf 的 %f 也是 double 型的转换说明（注意 %f 不是 float 型的转换说明）。

// 浮点数比较大小不能用等号，要用作差法比较。

// 变量的定义和赋值也可以一步完成，这称为变量的初始化（Initialization）。初始化是一种特殊的声明，而不是一种赋值语句 。


// ======================================================================
// 3. 函数入门
// ======================================================================



// ======================================================================
// 4. 分支语句
// ======================================================================



// ======================================================================
// 5. 深入理解函数
// ======================================================================



// ======================================================================
// 6. 循环语句
// ======================================================================





/********************************************************************************************
  2. 北京大学MOOC	C++	
********************************************************************************************/

//== 函数指针(指向函数的指针变量): ====================================
	类型名 (*指针变量名)(参数类型1, 参数类型2, ...)
用一个与原型匹配的函数的名字给一个函数指针赋值。

// 例:
int max(int var1, int var2)
{
	return (var1 > var2) ? var1 : var2;
}

int main()
{
	int (*max_ptr)(int, int);
	
	max_ptr = max;
	cout << max_ptr(5, 8) << endl;
}

//== 引用 =============================================================
	类型名 &引用名 = 某变量名;
1. 定义引用时一定要将其初始化为引用某个变量;
2. 引用只能在定义时被初始化一次，之后不可变;
3. 引用只能引用变量，不能引用常量和表达式。

// 利用引用交换两个变量的内容
void swap(int &var1, int &var2) 
{
	int temp;
	temp = var1;	var1 = var2;	var2 = temp;
}

//== 常引用(不能通过引用对目标变量的值进行修改)
	const  类型标识符 &引用名 = 目标变量名;

	
//== 动态内存分配 ====================================================
用"new"实现动态内存分配
	P = new T;  	// 分配变量
	P = new T[];    // 分配数组
T 是任意类型名，P 是类型为 T* 的指针。动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给 P。	

用"new"分配的动态内存，一定要用 "delete" 运算符进行释放
	delete 指针;  	// 改指针必须指向"new"出来的空间
	delete[] 指针;  // 释放动态分配的数组
	
// 例:
int main()
{
	int *data_ptr = new int;
	
	*data_ptr = 55;
	cout << *data_ptr << endl;
	delete data_ptr;
}


//== 函数重载 ========================================================
(函数名相同，而函数的参数的个数或函数参数的类型不同，或使用关键字"const"进行重载) 
// 例:
int max(int a, int b)  {}
int max(float v1, float v2)  {}
int max(int v1, int v2, int v3)  {}


//== 函数缺省参数 ====================================================
C++中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。

// 例:
void func(int a=2, int b=3, int c=1)  {}
func(5, 6);  // 等效于func(5, 6, 1);
func(5); 	 // 等效于func(5, 3, 1);


//== 构造函数 ========================================================
构造函数是成员函数的一种，主要用来在创建对象时初始化对象，即为对象成员变量赋初始值。


//== 复制构造函数 ====================================================
只有一个构造函数，即对同类对象的引用。X::X(X &) 或 X::X(const X&)




	
/***********************************************

  code:  (note; question; think)
  
***********************************************/
// 1.


// 2.













